### 继承/static/抽象类



#### 补充

* 类路径class path是所有包含类文件的路径的**集合**(类路径是JVM搜索类的起点)



* 概念上, **实例==对象**



* 创建类的格式: 类名 变量名 = new 构造器; 构造器只初始化对象,不创建对象;

* 构造器会返回初始化后的对象;



#### 静态

* 静态变量不常用, 但静态常量常用; 

* 何时使用静态方法: 

   * 方法不访问对象的成员, 所需参数显式提供;

   * 方法只访问类的静态成员;



* 静态与实例成员的被访问限制: 

   * 静态成员共被共享, 能被所有类型的成员访问;

   * 实例成员只能被所在对象/同一个对象的其他成员访问;



#### 继承

* 在类中this(...)意为调用其他构造器;



* 子类构造器必先调用父类构造器,未显式调用则隐式调用, 父类没有对应的相同参数列表的构造器则编译报错;



* super只是个用来指示编译器的关键字, 而非类似this是对象的引用;因此this.super......之类的声明会报错, 因为super不是属于本对象的内容;



* ==**?**子类继承自父类的**私有成员**(field), 子类中无法直接访问; 但可以使用例如**反射**的方法访问到;(考试一律认为子类不能继承父类的私有成员)==



* ==子类可以访问父类的静态成员;(但个人认为子类没有继承, 只是子类在声明上也是父类, 共享访问父类的静态成员)==



* static修饰的成员属于类, 未被修饰的成员属于对象;




* 访问静态成员用类名访问; 因静态成员被实例共享, 也能使用对象名访问, 但因内存机制效率较低;



* 在子类中存在方法重写时, 要调用父类方法使用: super.method()... 



#### 方法的调用机制

来自<<java核心技术>>: 

x.f(String), x声明为A类的一个对象;

* 编译时, 编译器先检索x的声明类型及其父类中所有同名方法;
* 若上一步出现多个同名方法,则开始匹配参数列表;
* 若没有匹配的方法,则开始对实参向上转型,继续匹配, 找到唯一匹配的方法;
* 若仍出现多个匹配的方法, 则编译报错;

当确定要调用的方法名及其参数列表后: 

* 若方法被private, static, final 修饰, 则在编译时即可**静态绑定**要调用的方法;
  * ? 若被private修饰, 则调用发生在方法定义的类里, 就近直接调用;
  * ? 若被static修饰, 则方法属于类, 只会被x声明的类型调用, 与x的实际类型无关;
  * ? 若被final修饰, 则方法不会被子类继承, 因而不会被重写, 方法签名唯一;
* 若方法不被以上修饰, 则会在运行时进行**动态绑定**, JVM预先为每个类创建方法表, 通过查询方法表决定调用哪个方法**(由x的实际类型决定)**;





